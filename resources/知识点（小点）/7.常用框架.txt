加载驱动方法
	1.Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
	2. DriverManager.registerDriver(new com.mysql.jdbc.Driver());
	3.System.setProperty("jdbc.drivers", "com.mysql.jdbc.Driver");

POJO类对象的状态
	自由状态（Transient）：实体在内存中自由存在，与数据库中的记录无关
	持久状态（Persistent）：实体处于由Hibernate框架所管理的状态，对应了数据库中的一条记录，同时与某个session实例发生了关联
	游离状态（Detached）：在session 关闭之后,可以使对象从持久状态转换到游离状态。
	

Servlet的生命周期
	初始化阶段
		加载Servlet类及.class对应的数据
		创建ServletConfig对象
		创建Servlet对象
	运行阶段
		service
	销毁阶段
		destroy
		
使用Servlet过滤器，需要在web.xml中配置 <filter-mapping>
context.getParameter()是获取POST/GET传递的参数值；
context.getInitParameter获取Tomcat的server.xml中设置Context的初始化参数
context.getAttribute()是获取对象容器中的数据值；
context.getRequestDispatcher是请求转发。
hibernate
	Hibernate中get()采用立即加载方式，load()采用延迟加载方式
	hibernate
	1.读取并解析配置文件
	2.读取并解析映射信息，创建SessionFactory
	3.打开Sesssion
	4.创建事务Transation
	5.持久化操作
	6.提交事务
	7.关闭Session
	8.关闭SesstionFactory
		1，Configuration接口：配置Hibernate，根据其启动Hibernate，创建SessionFactory对象；
		2，SessionFactory接口：初始化Hibernate，充当数据存储源的***，创建session对象，SessionFactory是
		线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级二级缓存；
		3，session接口：负责保存、更新、删除、加载和查询对象，是一个非线程安全的，避免多个线程共享一个session，是轻量级，一级缓存。
		4，Transaction接口：管理事务。可以对事务进行提交和回滚；
		5，Query和Criteria接口：执行数据库的查询。
分页步骤
	1、count(*)得到总记录数
	2、计算总页数
	3、获取所有记录(个人感觉这一步不需要，可以直接获取指定页数数据)
	4、过滤显示本页数据
Spring框架
	Spring
		轻量级javaEE框架
		包含依赖注入模式
		包含声明式食物
		提供AOP，但没有提供AOP方式的日志系统
	好处：轻量级；控制反转(IOC)：实现松散耦合；面向切面编程(AOP)：将业务逻辑和系统服务区分开来
	
	自动装配方式有哪些
		no:不自动装配
		byName:根据Bean的名字进行自动装配
		byType:根据Bean的类型进行自动装配
		constructor：Bean与构造器的参数类型相同进行自动装配
		autodetect:先使用constructor进行装配，失败再使用byType
		使用注解@Autowired
	Bean的作用域
		singleton:单实例
		prototype:多实例，每次调用Bean,创建一个新的实例
		request：每次HTTP请求创建新的实例
		session：HttpSession共享同一个Bean
		globalSession：同一个全局Session共享一个Bean
	Bean的生命周期
		实例化Bean
		设置对象属性(依赖注入)
		处理Aware接口
		BeanPostProcessor
		initializingBean于init-method
		DisposableBean
		destroy-method
	IOC控制反转（松耦合，更优良）
		控制：不使用传统的new进行创建对象，而是将设计好的对象交给IOC容器来控制创建和管理生命周期
		反转：不是对象主动获取依赖，而是容器帮我们查找对象，对象被动的接受依赖对象
		步骤：定义bean的java类，使用xml配置文件，解析bean的配置，反射创建类
	DI依赖注入
		依赖关系写入配置文件中，即对象注入属性，需要再IOC的基础上完成
		依赖注入方式：构造方法注入，setter方法注入，接口注入
	AOP面向切面编程
		需要对多个对象引入一个公共行为，如记录日志，权限控制，缓存优化，事务管理等，减少代码重复
		切面：拦截器定义切点和通知
		切点：具体拦截的某个业务点
		通知：切面中的方法，声明通知方法在目标业务层的执行位置
			通知类型：
				前置通知 @Before
				后置通知 @After
				返回通知 @AfterReturning
				异常通知 @AfterThrowing
				环绕通知 @Around
	Spring支持的事务管理类型有哪些
		支持编程式事务管理和声明式事务管理
			Spring框架用户大多选择声明式事务管理，因为和应用程序的关联少，更符合轻量级容器的概念
			声明式要优于编程式，尽管在灵活上弱于编程式，因为编程式允许通过代码控制业务
		事务分为全局事务和局部事务
			全局事务由应用服务器管理，需要底层服务器JTA支持(如WebLogic,WildFly等)。
			局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化式，需要使用Connection对象来操作事务，
				采用hibernate进行持久时，需要使用Session对象来操作事务
		事务的父接口都是PlatformTransactionManager,
			它的实现类必须提供
				getTransaction()方法  开启事务
				commit()方法  提交事务
				rollback()方法 回滚事务
	注解
		@Autowired和@Resource
			@Autowired（在User中自动注入cat）
				按照byType类型自动注入
			@Resource(name="cat")(看起来更清晰)
				有两个属性name和type,什么都不设/使用name-byName自动注入，使用type:byType自动注入
		@Transaction 事务注解,原子性、一致性、隔离性、持久性
		

SpringMVC
	组件
		前端控制器DispatcherServlet:接收请求，相应结果，
		处理器映射器HandlerMapping：更具请求的URL来查找Handler
		处理器适配器HandlerAdapter:
		视图解析器ViewResolver进行 视图解析
		视图jsp页面
	SpringMVC执行流程
		用户请求发送给前端控制器
		前端控制器收到请求，调用处理器映射器，找到对应的处理器，返回个前端控制器
		前端控制器器调用处理器适配器
		经过适配，调用处理器
		处理器执行完返回ModelAndView
		适配器将ModelAndView返回给前端控制器
		前端控制器传给视图解析器进行解析返回具体View
		前端控制器对view进行渲染，响应给用户

Spring
	@Component 组件，没有明确的角色
	@Service 在业务逻辑层使用（service层）
	@Controller 在展现层使用，控制器的声明（C
	@Repository 在数据访问层使用（dao层）
	@Aurowired和@Resource
		@Autowired（在User中自动注入cat）
			按照byType类型自动注入
		@Resource(name="cat")(看起来更清晰)
			有两个属性name和type,什么都不设/使用name-byName自动注入，使用type:byType自动注入
	@Transactional 事务注解,原子性、一致性、隔离性、持久性
	

springboot	
	注解	
		@SpringBootApplication - 表面是主类-最重要
		@Mapper
		@Select
		@Controller
		@Autowired
		@RequestMapping
		@Data

ajax  
	在无需重新加载整个页面的情况下，更新部分网页的技术
