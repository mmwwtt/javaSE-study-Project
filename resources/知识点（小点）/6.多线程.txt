

并发和并行的区别
	并发：一个CPU上，一个线程在执行，其他线程被挂起
	并行：多个CPU上，两个线程互不干涉，不抢占资源
	
异步和同步
	异步：多个线程同时进行
	同步：同时只能有一个线程
	
线程安全(同步)
	不会被别的线程所影响，方式：添加synchronized关键字/实现lock锁
	
线程的状态（生命周期）
	新建、就绪、运行、阻塞、死亡（就绪态和运行态是双向的，其他都是按照顺序单向的）
	start()启动线程，进入可运行状态，当得到cpu时间片后，开始调用run方法（线程体），run方法没有实现，则无法执行
	run()，直接调用只是普通方法，
	sleep()阻塞当前线程，并不释放锁对象
	wait()阻塞当前线程，释放锁对象给其他竞争同一个锁的线程
		notity/notifyAll唤醒等待线程继续执行
	join()等待当前线程运行结束,会释放锁资源
	

	
线程和进程的区别
	进程是操作系统资源分配的单位
	线程是任务调度和执行的单位
	操作系统中有多个进程(程序)，每个进程中有多个线程
	
线程池的作用
	效率高：创建好的线程放在线程池中，使用时就拿出来用
	方便管理：对线程进程同一管理，多出的线程可以排队，避免无休止创建线程导致崩溃
	
死锁的4个必要条件
	互斥条件
	请求和保存条件
	不可抢占条件
	循环等待条件
	
预防死锁
	一次性分配，只要有一个资源得不到分配，就不给这个进程分配资源（破坏请求与保持）
	可剥夺资源：当进程只能获得部分资源，则可以释放占用的资源（破坏不可抢占）
	资源有序分配：为资源编号
	，
悲观锁和乐观锁
	悲观锁：处理数据设置为锁状态，别人拿数据就会阻塞
	乐观锁：适用于多读的场景，通过增加版本号字段，如果前后版本号不一致，将重新提交，跟新数据时版本号+1.
		增加了一个字段，浪费了空间，但并发性更好，节省时间
		

JMM(Java memory model)java内存模型
	是个抽象的概念
Synchronized和lock的区别
	synchronized 修饰方法/代码块/对象 不修饰变量
	Synchronized是关键字，lock是接口
	Synchronized在异常时会自动释放占有的锁，不会死锁；lock不会主动释放占有的锁，需要unlock手动来释放，可能会死锁
	Synchronized不能知道有没有获得锁，lock可以通过trylock来知道
	Synchronized不可以让等待锁的线程中断，lock可以
	大量线程同时竞争时，Lock的性能优于Synchronized
	synchronized
		方法前和synchronized(this)是，锁住对象实例
		静态方法和synchronized(类名.class)，锁住类的所有对象


想要读写平均，使用锁机制保证线程安全，最好的方法是：分区段加锁(只在读写的地方加读写锁)



线程安全的有
	枚举
	静态内部类
	双检锁模式
	饿汉式

线程局部存储TLS(thread local storage)
	解决多线程中的对同一变量的访问冲突的一种技术
	TLS会为每一个线程维护一个和该线程绑定的变量的副本
	Java平台的java.lang.ThreadLoacl是TLS技术的一种实现
	存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递，在线程消失之后，其线程局部实例的所有副本都会被垃圾回收

在Thread类中有一个Map，用于存储每一个线程的变量的副本
java中监视器机制实现了线程的同步执行


原子性（前三个都要先读取后操作，x=1直接赋值，所以只有最后一个是原子性的）
	x++ 
	++x
	x=y
	x=1

volatile功能：有序性，可见性
	用volatile修饰的变量，每次更新对其他线程都是立即可见的。
	对volatile变量的操作不会造成阻塞。
run方法会导致线程销毁

File类能够存储文件属性
File类不能读写文件
File类能建立文件
File类能获得文件目录信息