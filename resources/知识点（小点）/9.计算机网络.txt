
应用层：定义了应用进程之间通信和交互的规则
	DNS域名解析系统：将域名转换为IP地址
	HTTP超文本传输协议：无状态，无连接，明文传输，不安全，端口80
	HTTPS超文本传输安全协议：加密传输，相对安全，端口443
	FTP文件传输协议:使用TCP的可靠传输服务
运输层：两台主机中进程之间数据传输
	UDP用户数据报协议:传输数据报，面向无连接，尽最大努力交付，不保证可靠传输，多对多
	TCP传输控制协议:传输的是报文，面向连接，一对一，先建立链接，再进行可靠的数据传输服务(无差错，不丢失，不重复，按需到达)
网络层：提供通信服务
	IPv4和IPv6的区别
		IPv4的IP地址长度是32，IPv6的IP地址长度是128
		IPv6安全性更高，可对网络层数据进行加密
	IP网际协议：一般指IPv4
	ARP地址解析协议：从网络层的IP地址解析出在数据链路层使用的硬件地址
	ICMP网际控制报文协议：数据加上首部后组成IP数据报，差错报告和询问报告
链路层：将数据报封装成帧
	PPP点对点协议：只检测差错而不纠正差错，不进行流量控制，
物理层：屏蔽传输媒体和通信手段的差异，使数据链路层只考虑本层协议和服务，传输的是比特1/0

TCP三次握手和四次挥手
	三次握手(SYN建立联接，ACK确认)
		客户端发送syn包(seq=j)给服务器，等待服务器确认
		服务器收到syn包，发送ack包(ack=j+1)和syn(seq=k),给客户端，服务器进入接收状态
		客户端检查ack是否正确，发送ack包(ack=k+1)给服务器，服务器检查正确则建立连接
		完成三次握手，建立TCP连接
	四次挥手
		客户端发送fin=j，表示不发送报文了
		服务端发送ack=j+1,告知客户端已知道，同时需要等待服务端发完所有报文
		服务端发送,fin=k,表示准备关闭
		客户端发送 ack=k+1，确认 关闭连接
为什么连接的时候是三次，关闭的时候是四次
	连接时服务端收到SYN后可以同时发送ACK和SYN
	关闭时服务端手段FIN后需要先发送ACK确认同时让客户端等待服务端发完所有报文，然后再发送FIN给客户端
为什么不能两次握手进行连接
	两次握手服务端不能缺点客户端是否收到了自己的ack和syn信息
	可能会出现建立连接后，服务端发数据客户端收不到
浏览器状态
	3XX需要进行重定向
	404客户端请求错误，服务端无法找到所请求的资源
	500服务器错误，无法完成请求

项目介绍
	小型购物平台
	采用SpringBoot+MyBatis技术，使用了mysql数据库
	完成了注册登入，商品展示，分页，加入购物车等模块
	这个项目是作为课堂学习使用的，课上我们使用的是Struts+Hibernate+JSP的方式来教学
	我后期通过学习SpringBoot技术将项目使用SpringBoot+Mybatis技术实现，很大程度上提高了代码的性能

TCP服务器端
	1.建立端口监听 socket()
	2.绑定指定端口 bind()
	3.listen 进行端口监听
	4.accept() 阻塞式 直到有客户端访问
	5.read()获取客户端发送数据
	6.write()发送返回数据
	7.close关闭端口监听
TCP客户端： 
	1.建立连接套接字，设置Ip和端口监听，socket()
	2.建立连接 connect
	3.write() 获取网络流对象 发送数据
	4.read()获取网络流对象 接收数据
	5.关闭套接字

.socket编程 就是一种方法:
	当你编程时候需要 跨网络发信息时， 把网络连通需要的各种复杂配置参数 隐藏起来并自动生成，
	只暴露出一个 "象征物"（对象/结构体 不同语言中叫法不一），让你操作这个"象征物"就能收发数据 的一种方法. 
服务器端：ServerSocket提供的实例 ServerSocket server = new ServerSocket(端口号) 
客户端：Socket提供的实例 Socket client = new Socket(IP地址，端口号)

