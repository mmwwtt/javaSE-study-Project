1. 静态内部类：
    1. 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化。
2. 成员内部类：
    1. 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。
3. 局部内部类：abstract，final可用来修饰
    1. 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。
    2. 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。
4. 匿名内部类：
    1. 没有类名的内部类，不能使用class，extends和implements，没有构造方法。
    2. 多用于GUI中的事件处理。
    3. 不能定义静态资源
    4. 只能创建一个匿名内部类实例。
    5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。
    6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效。

解决hash冲突
	开放地址法
	链地址法
	再哈希法
	建立一个公共溢出区
	
volatile关键字
	保证可见性
synchronized关键字
	保证原子性，解决时多线程同步访问资源

线程之间通知和唤醒

Object.wait
notify
notifyAll
Thread.wait

java链接数据库（原生）
	Statement对象的作用是执行sql语句
	
has-a
is-a


1、堆区（heap）：用于存放所有对象，是线程共享的（注：数组也属于对象）
2、栈区（stack）：用于存放基本数据类型的数据和对象的引用，是线程私有的（分为：虚拟机栈和本地方法栈）
3、方法区（method）：用于存放类信息、常量、静态变量、编译后的字节码等，是线程共享的（也被称为非堆，即 None-Heap）

Java 的垃圾回收器（GC）主要针对堆区
方法调用时，会创建栈帧在栈中，调用完是程序自动出栈释放，而不是gc释放


finalize是方法名，在垃圾收入集器将对象从内存中清除出去之前做必要的清理工作

创建对象的方法
	new(用到构造方法)
	序列化对象
	反射(用到构造方法)
	克隆
	
	
运行时异常有jvm处理
非运行时异常才需要抛出
IOException
SqlException
输入输出流编程中，读写都要抛出异常
FileOutputStream
DataOutputStream




JVM中的GC
	GC管理的内存
	进程管理的内存
	老年代
	新生代

线程共享的是方法区和java堆

>>
>>>
<<

多态中的编译看左,运行看右
jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些
	老年堆满
	持久代满
	System.gc()

final类型变量一定要显式初始化，默认初始化无效


Collection是java.util下的接口，它是各种集合结构的父接口
Collections是java.util下的类，它包含有各种有关集合操作的静态方法

object中的方法
    clone()
    toString()
    wait()
    finalize()


二维数组中第一个[]必须有值
    float f[][] = new float[6][6];
    float []f[] = new float[6][6];
    float [][]f = new float[6][6];
    float [][]f = new float[6][];

实现单例线程安全的模式
    枚举
    静态内部类
    双检锁模式
    饿汉式

程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的
虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的
它与堆一样，是被 线程共享 的区域。 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。
原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的